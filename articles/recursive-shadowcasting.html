<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>视野计算：递归投影算法</title>
  <link rel="stylesheet" href="../css/blog.css" />
</head>
<body>
  <div class="main">
    <div class="menu">
      <div class="link">
        <p>Sci-Twi<p>
        <p><a href="../index.html" id="mainPage">主页</a></p>
        <p><a target="_blank" id="githubPage">Github页面</a></p>
      </div>
    </div>
    <div class="article">
      <div class="title">
        <h1>视野计算：递归投影算法</h1>
        <div class="tags">
          <div class="tag">翻译</div>
          <div class="tag">算法</div>
          <div class="tag">RPG</div>
          <div class="tag">Roguelike</div>
        </div>
      </div>
      <hr/>
      <div class="text">
        <p><a href="https://www.roguebasin.com/index.php?title=FOV_using_recursive_shadowcasting" target="_blank">视野计算：递归投影算法 - Björn Bergström [bjorn.bergstrom@roguelikedevelopment.org]</a></p>
        <p>翻译：Sci-Twi</p>
        <br/>
        <h3>简介</h3>
        <hr/>
        <p>一个运作的视野（通常称为视线）算法是任何一款Roguelike游戏中必不可少的一部分。一个视野算法在一个给定的半径内计算哪些地图单元格是可见的；或者如果有光源的话，哪些地图单元格能被照亮。</p>
        <p>最简单的方法是，追踪从中心出发、所有半径边缘的地图单元格为终点的线段，在有地图单元格挡住视线的时候停止。这个方法的问题在于许多地图单元格被访问了很多次，往往是靠近起始点的次数更多，靠近边缘的次数更少。能够提升这个简单方法的性能的东西不多。最明显的是扫描中命中障碍物时性能可以得到提升。经过简单的计算后，所有穿过该障碍物的光线都可以被跳过，由此提升性能。所有这些都在其他有关视线的文章中详细讨论。<a href="https://www.roguebasin.com/index.php/Line_of_Sight_-_Tobias_Downer" target="_blank">Line of Sight - Tobias Downer</a>是一个不错的起点。</p>
        <p>即使实施了以上描述的“跳过光线”步骤，也有很多地图单元格会被访问不止一次，从而浪费CPU时间。为了克服这个问题，必须使用一种完全不同的方法。这个方法就是“投影”。</p>
        <br/>
        <h3>投影</h3>
        <hr/>
        <p>投影将视野计算分为了八个八分之一区域，并且访问每个地图单元格的方式和前文提到的光线投射算法完全不同。与追踪从中心开始到边缘的线段相比，投影逐行或逐列地访问每个地图单元格，从最近的行或列开始向外运行。</p>
        <pre>

   ------>  6 行6最后
    ----->  5 .
     ---->  4 .
      --->  3 .
       -->  2 行2第二
        ->  1 行1最先被扫描
         @  @ 此为起点

  图.2a 投影的扫描顺序
        </pre>
        <p>当某次扫描遇到挡住了视线的障碍物时，其将计算行/列中哪些其他的更远的单元格是因为障碍物而不可见的。那些单元格将“处于阴影中”，因此有了投影的说法。</p>
        <pre>

   -...---  - = 可见的单元格
    -..---  # = 障碍物
     -#---  . = 处于障碍物阴影之中的单元格
      ----
       ---
        --
         @

  图.2b 障碍物阴影之中的单元格
        </pre>
        <p>Gordon Lipford的<a href="https://www.roguebasin.com/index.php/Computing_LOS_for_Large_Areas" target="_blank">Computing LOS for Large Areas</a>一文中详细描述了普通的投影算法。Gordon的算法使用了临时数组，并且相当复杂。使用递归可以实现一个只访问障碍物和非障碍物，忽视阴影部分单元格的干净、精致、快速的算法。此算法在走廊、小房间等限制区域尤其的快。</p>
        <br/>
        <h3>定义</h3>
        <hr/>
        <p>为了了解递归投影算法，我们需要了解什么是一条线段的斜率和反斜率。斜率是由这个简单的公式计算的：</p>
        <pre>slope = (x1 - x2) / (y1 - y2)</pre>
        <p>如果我们在[6,6]和[5,3]间画一条线段，那么斜率将是：</p>
        <pre>slope = (6 - 5) / (6 - 3) = 1 / 3 = 0.33333</pre>
        <p>如果我们沿着线段行进，我们会发现y每减少1，x将减少0.33333。</p>
        <p>反斜率则是简单的1 / 斜率。</p>
        <br/>
        <h3>递归投影算法</h3>
        <hr/>
        <p>递归投影算法将视野分为了有着共有边的八个八分之一区域。标出八分之一区域时，视野看上去像这样：</p>
        <pre>

              1 & 2的
  1 & 8的     共有边    2 & 3的
  共有边 \      |      /共有边
          \     |     /
           \1111|2222/
           8\111|222/3
           88\11|22/33
           888\1|2/333
  7 & 8的  8888\|/3333  3 & 4的
  共有边 -------@-------共有边
           7777/|\4444  
           777/6|5\444
           77/66|55\44
           7/666|555\4
           /6666|5555\
          /     |     \
  6 & 7的/      |      \4 & 5的
  共有边      5 & 6的   共有边
              共有边 
             

 图.4a 每个八分之一区域的覆盖范围
        </pre>
        <p>和普通的投影算法一样，此递归投影算法逐行或逐列地扫描某个八分之一区域，而扫描是逐行或逐列取决于是哪个区域。每个八分之一区域中距离起点最近的行/列最先被扫描。</p>
        <p>区域1和6逐行执行扫描，每行从最左侧单元格开始到最右侧单元格。</p>
        <p>区域2和5逐行执行扫描，每行从最右侧单元格开始到最左侧单元格。</p>
        <p>区域3和8逐列执行扫描，每行从最上方单元格开始到最下方单元格。</p>
        <p>区域4和7逐列执行扫描，每行从最下方单元格开始到最上方单元格。</p>
        <p>当一个障碍物被发现时，程序将会立刻在下一行/列上递归启动一次新的扫描，覆盖该区域，直到该扫描的起始单元格处于障碍物的阴影中。随后，扫描将跳过该障碍物相邻的障碍物，对余下最初的行/列进行扫描。如果发现了紧随障碍物后的新的、连续的非障碍物的一部分，则程序继续重复运行。</p>
        <p>我将会试着使用一些简单的ascii字符画说明以上描述的程序。我们希望计算的视野区域是这样的：</p>
        <pre>

 ................. 16  @ = 起始单元格
  ......###....... 15  # = 障碍物
   .....###....... 14  . = 非障碍物
    ....###..#..## 13 
     ...##........ 12
      ............ 11
       ........... 10
        .......... 9
         ......... 8
          ........ 7
           ....... 6
            ...... 5
             ..... 4
              .... 3
               ... 2
                .. 1
                 @

  图.4b 视野
        </pre>
        <p>从左往右进行的行1到11的扫描没有任何问题。和之前描述的一样，扫描接触到最右侧的单元格时，在下一行启动一个新的扫描。</p>
        <p>如果我们画一条从起始单元格中心到最左侧单元格中心的线段，会发现这条线段的斜率是1。我们把这叫做为扫描的起始斜率。相同的，最右侧单元格得到的线段的斜率是0。这叫做扫描的终止斜率。</p>
        <p>当我们到达了12行时，事情变得有趣了一些。我们在第12行命中障碍物时，一次递归开始了。</p>
        <pre>

  ................. 16  # = 障碍物
   ......###....... 15  . = 非障碍物
    .....###....... 14  
     ....###..#..## 13 
      ...x#........ 12  x = 第一个障碍物

  图.4c 第一个障碍物
        </pre>
        <p>命中第一个障碍物（x）时，一次新的扫描将在13行开始。起始斜率当然和之前的行相同（也就是1），但终止斜率不同。计算终止斜率需要使用一条线段，其需经过起点的中心点，到达一个“掠过”该障碍物最左侧的点。如果我们放大看大概是这样的：</p>
        <pre>

  +---+xxxxx#####  x = 第一个障碍物
  |   |xxxxx#####  a = “掠过”该障碍物最左侧的点
  |   |xxxxx#####
  |   |xxxxx#####
  +---axxxxx#####
  +---++---++---+
  |   ||   ||   |
  |   ||   ||   |
  |   ||   ||   |
  +---++---++---+

  图.4d 放大看第一个障碍物
        </pre>
        <p>因此，该扫描的终止斜率可以由一条从起点中心出发，到达图中标出的“a”的位置的线段获得。该终止斜率大约为0.82。</p>
        <p>现在我们有着两个扫描：原始的那个将继续扫描12行直到到达最右侧单元格；新的那个则开始扫描13行，从最左侧单元格（起始斜率1）开始，到和在13行的与斜率为0.82（终止斜率）的直线相交的单元格：</p>
        <pre>

  2222............. 16  # = 障碍物
   2222..###....... 15  . = 非障碍物
    222..###....... 14  
     222.###..#..## 13  1 = 原始扫描
      111##11111111 12  2 = 新扫描

  图.4e 现有的扫描
        </pre>
        <p>现在让我们回到处于12行的原始扫描。该扫描刚刚遇到了第一个障碍物，并使用新的终止斜率在下一行创建了递归扫描。而现在该扫描检测了下一个单元格，发现此单元格中也是障碍物。因为前一个单元格也是障碍物，而我们遇到的是障碍物的一部分，因此我们只需要继续扫描，直到遇到下一个非障碍物：</p>
        <pre>
          
 ................. 16  # = 障碍物
  ......###....... 15  . = 非障碍物
   .....###....... 14  
    ....###..#..## 13 
     ...##o....... 12  o = 在一段障碍物后出现的第一个非障碍物

  图.4f 第一个非障碍物
        </pre>
        <p>当发现一段连续的障碍物后的非障碍物时，我们需要计算扫描所需要的新的起始斜率。这将使用一条线段，其需经过起点的中心点，到达一个“掠过”障碍物最右侧的点来完成。如果我们放大看大概是这样的：</p>
        <pre>

  ##########aoooo  o = 第一个非障碍物
  ##########o   o  a = “掠过”障碍物最右侧的点
  ##########o   o
  ##########o   o
  ##########ooooo
  +---++---++---+
  |   ||   ||   |
  |   ||   ||   |
  |   ||   ||   |
  +---++---++---+

  图.4g 放大看第一个非障碍物
        </pre>
        <p>因此，该扫描的起始斜率可以由一条从起点中心出发，到达图中标出的“a”的位置的线段获得。该起始斜率大约为0.6。</p>
        <p>一旦一个扫描到达最后一个单元格，当且仅当最后一个单元格不是障碍物时，此扫描将结束并启动一个新的扫描。假使在我们的原始扫描中最后一个单元格不是障碍物，则在下一行使用一个新的起始斜率0.6（而不是原来的1）启动一个新的扫描。</p>
        <p>当原始扫描在行13启动时，立刻发现了一个障碍物：</p>
        <pre>

  ................. 16  # = 障碍物
   ......###....... 15  . = 非障碍物
    .....###....... 14  
     ....##x..#..## 13  x = 原始扫描检测到的障碍物

  图.4h 启动时检测到障碍物
        </pre>
        <p>与此同时我们继续扫描，直到发现另一个非障碍物。这样的话下一个单元格是一个非障碍物，我们计算出一个新的起始斜率，和在行12中我们经过那一段连续的非障碍物时的方式相同。这一切完成后我们继续从左到右扫描，直到我们到达最后一个单元格或命中障碍物。在我们的例子中，到达最后的单元格前就找到了障碍物：</p>
        <pre>

  ................. 16  # = 障碍物
   ......###....... 15  . = 非障碍物
    .....###....... 14  
     ....##...x..## 13  x = 原始扫描检测到的障碍物

  图.4i 另一个障碍物
        </pre>
        <p>于是，现在递归启动了一个新的扫描，和行12的方式相同。该扫描和原始扫描有着相同的起始斜率（0.6）和一条“掠过”障碍物左侧的点的直线的终止斜率（图.4i中以“x”标出）。现在我们有三个活跃扫描：</p>
        <pre>

  2222......33..... 16
   2222..##333..... 15
    222..##333..... 14  
     222.###11#11## 13  

  Fig.4j 活跃扫描
        </pre>
        <p>当我们的移动出障碍物区域时，再次重复相同的程序，找到了两个新的非障碍物，然后碰到了又一个障碍物：</p>
        <pre>

  2222......33444.. 16
   2222..##333.44.. 15
    222..##333.44.. 14  
     222.##111#11## 13  

  Fig.4k 活跃扫描
        </pre>
        <p>当原始扫描结束在行13的最右侧单元格时，是以一个障碍物，而不是像行12一样以一个非障碍物结束的。因为原始扫描以一个障碍物结束，所以将不再在下一行启动一个新的扫描。现在我们将用扫描2，3和4来完成剩余的视野扫描工作。这些扫描和原始扫描有着相同的程序和规则。</p>
        <p>当扫描完成后我们得到了这样的视野：</p>
        <pre>

  ....ssssss.....ss 16  @ = 起始单元格
   ....ssss#..s..ss 15  # = 障碍物
    ...ssss#..s..ss 14  . = 非障碍物
     ...ss##..#..## 13  s = 阴影单元格
      ...##........ 12
       ............ 11
        ........... 10
         .......... 9
          ......... 8
           ........ 7
            ....... 6
             ...... 5
              ..... 4
               .... 3
                ... 2
                 .. 1
                  @
        </pre>
        <p>此程序在其他八分之一区域重复运行，因此能够产生一个完整的视野。你可以在这里找到一个实现的源码和可执行程序。</p>
        <p>©2001 Björn Bergström bjorn.bergstrom@roguelikedevelopment.org</p>
        <br/>
        <h3>实现</h3>
        <hr/>
        <p><a href="https://www.roguebasin.com/index.php/Improved_Shadowcasting_in_Java" target="_blank">一个改进版本的Java实现</a></p>
        <p><a href="https://www.roguebasin.com/index.php/PythonShadowcastingImplementation" target="_blank">一个该算法的Python实现</a></p>
        <p><a href="https://raw.githubusercontent.com/irskep/clubsandwich/afc79ed/clubsandwich/line_of_sight.py" target="_blank">上方Python实现的一个更具有Python风格的改写版本</a></p>
        <p><a href="https://www.roguebasin.com/index.php/Ruby_shadowcasting_implementation" target="_blank">一个Ruby实现</a></p>
        <p><a href="https://www.roguebasin.com/index.php/C%2B%2B_shadowcasting_implementation" target="_blank">一个C++实现</a></p>
        <p><a href="http://nemonon.de/blog/?p=10" target="_blank">ActionScript 3实现</a></p>
        <p><a href="http://www.evilscience.co.uk/?p=225" target="_blank">C#实现</a></p>
        <p><a href="http://fadden.com/tech/ShadowCast.cs.txt" target="_blank">详细注释的C#实现</a></p>
        <p><a href="https://gitlab.com/valeevmaratraf/3d-fov-shadowcasting/-/blob/main/ShadowCast3D.cs?ref_type=heads" target="_blank">3D可见度体积计算投影</a></p>
      </div>
    </div>
  </div>
  <script src="../js/blog.js"></script>
</body>
</html>